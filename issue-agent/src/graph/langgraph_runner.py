import os
from typing import Any, List, Optional, TypedDict

from github import Github
from IPython.display import Image, display
from langgraph.graph import END, StateGraph
from src.agents.suggestion_agent import generate_contextual_suggestion
from src.tools.codebase_fetcher import get_codebase_as_dict, extract_file_path_from_body
from src.agents.reviewer_agent import get_reviewer_agent
from dotenv import load_dotenv
load_dotenv()

class AgentState(TypedDict):
    input: str
    review_result: Optional[Any]
    decision: Optional[bool]
    issues_to_create: Optional[List[dict]]
    generation_result: Optional[Any]
    issues_to_create_numbers: Optional[List[int]]  # ← add this line


def reviewer_node(llm, tools):
    import json

    agent = get_reviewer_agent(llm, tools)

    def run(state: AgentState) -> AgentState:
        print("🧠 Reviewer agent thinking...")
        raw_result = agent.invoke({"input": state["input"]})
        print("🧠 Raw result from LLM:", raw_result)

        create_issues = False
        issues = []

        result_str = raw_result.get("output", "")
        if isinstance(result_str, str):
            try:
                result_str = result_str.strip()
                if result_str.startswith("```json"):
                    result_str = result_str.removeprefix("```json").strip("` \n")
                parsed = json.loads(result_str)
                print("✅ Parsed JSON result:", parsed)

                # ✅ Use the parsed JSON now
                create_issues = parsed.get("create_issues", False)
                issues = parsed.get("ISSUES", [])
                return {
                    **state,
                    "review_result": parsed,
                    "decision": create_issues,
                    "issues_to_create": issues,
                }

            except Exception as e:
                print(f"❌ Error parsing JSON result: {e}")

        print("🧪 Fallback decision: False (no valid JSON)")
        return {
            **state,
            "review_result": raw_result,
            "decision": False,
            "issues_to_create": [],
        }

    return run


def generator_node():
    def run(state: AgentState) -> AgentState:
        print("⚙️ Generator creating issues...")
        gh = Github(os.environ["GITHUB_TOKEN"])
        repo = gh.get_repo(os.environ["GITHUB_REPO"])
        results = []

        label_name = "issue-agent"
        existing_labels = [label.name for label in repo.get_labels()]
        if label_name not in existing_labels:
            repo.create_label(
                name=label_name,
                color="f29513",
                description="Auto-generated by Issue Agent",
            )
        numbers = []
        for issue in state.get("issues_to_create", []):
            title = issue.get("title", "").strip() or "Untitled"
            body = issue.get("body", "").strip() or "No description provided."

            full_title = f"[Issue Agent] {title}"
            full_body = f"{body}\n\n---\n_This issue was generated automatically by `issue-agent [Generator-sub-agent]`._"

            created = repo.create_issue(
                title=full_title, body=full_body, labels=[label_name]
            )
            numbers.append(created.number)
            print(f"🔢 Issue number: {created.number}")
            results.append(created.html_url)

        return {
            **state,
            "generation_result": results,
            "issues_to_create_numbers": numbers,
        }

    return run

def suggestion_node(llm):
    from src.tools.codebase_fetcher import extract_file_path_from_body, get_codebase_as_dict
    from src.agents.suggestion_agent import generate_contextual_suggestion

    code_dict = get_codebase_as_dict("codebase")
    print("✅ Loaded codebase dictionary with", len(code_dict), "files")

    def run(state: AgentState) -> AgentState:
        print("💬 Suggestion node with full LLM + source context")

        gh = Github(os.environ["GITHUB_TOKEN"])
        repo = gh.get_repo(os.environ["GITHUB_REPO"])
        numbers = state.get("issues_to_create_numbers", [])
        issues = state.get("issues_to_create", [])

        for issue_obj, issue_num in zip(issues, numbers):
            issue = repo.get_issue(number=issue_num)
            title = issue_obj.get("title", "")
            body = issue_obj.get("body", "")
            full_body = f"{body}\n\n---\n_This issue was generated automatically by `issue-agent [Suggestions-sub-agent]`._"

            response = generate_contextual_suggestion(
                llm,
                code=code_dict,  # Limit to ~1200 chars for clarity
                issue_body=full_body
            )
            issue.create_comment(response if isinstance(response, str) else response.content)
            print(f"✅ Commented on #{issue_num} with LLM suggestion.")

        return state

    return run


def should_create_issues(state: AgentState) -> str:
    return "create" if state.get("decision") else "end"


def build_multi_agent_issue_graph(llm, tools, compile_graph=True):
    graph = StateGraph(AgentState)
    graph.add_node("reviewer", reviewer_node(llm, tools))
    graph.add_node("generator", generator_node())
    graph.add_node("suggestion", suggestion_node(llm))

    graph.set_entry_point("reviewer")
    graph.add_conditional_edges("reviewer", should_create_issues, {"create": "generator", "end": END})
    graph.add_edge("generator", "suggestion")
    graph.add_edge("suggestion", END)

    return graph.compile() if compile_graph else graph



def get_graph_dot_string(llm, tools):
    builder = build_multi_agent_issue_graph(llm, tools, compile_graph=False)
    # with open("graph.dot", "w") as f:
    #     f.write(get_graph_dot_string(llm, tools))
    return builder.get_graph().get_dot()

# then in terminal:
# dot -Tpng graph.dot -o graph.png

# then in terminal:
# dot -Tpng graph.dot -o graph.png

