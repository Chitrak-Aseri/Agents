import os
from typing import Any, List, Optional, TypedDict

from github import Github
from IPython.display import Image, display
from langgraph.graph import END, StateGraph

from src.agents.reviewer_agent import get_reviewer_agent


class AgentState(TypedDict):
    input: str
    review_result: Optional[Any]
    decision: Optional[bool]
    issues_to_create: Optional[List[dict]]
    generation_result: Optional[Any]


import json

def reviewer_node(llm, tools):
    import json
    agent = get_reviewer_agent(llm, tools)

    def run(state: AgentState) -> AgentState:
        print("ðŸ§  Reviewer agent thinking...")
        raw_result = agent.invoke({"input": state["input"]})
        print("ðŸ§  Raw result from LLM:", raw_result)

        create_issues = False
        issues = []

        result_str = raw_result.get("output", "")
        if isinstance(result_str, str):
            try:
                result_str = result_str.strip()
                if result_str.startswith("```json"):
                    result_str = result_str.removeprefix("```json").strip("` \n")
                parsed = json.loads(result_str)
                print("âœ… Parsed JSON result:", parsed)

                # âœ… Use the parsed JSON now
                create_issues = parsed.get("create_issues", False)
                issues = parsed.get("ISSUES", [])
                return {
                    **state,
                    "review_result": parsed,
                    "decision": create_issues,
                    "issues_to_create": issues,
                }

            except Exception as e:
                print(f"âŒ Error parsing JSON result: {e}")

        print("ðŸ§ª Fallback decision: False (no valid JSON)")
        return {
            **state,
            "review_result": raw_result,
            "decision": False,
            "issues_to_create": [],
        }

    return run


def generator_node():
    def run(state: AgentState) -> AgentState:
        print("âš™ï¸ Generator creating issues...")
        gh = Github(os.environ["GITHUB_TOKEN"])
        repo = gh.get_repo(os.environ["GITHUB_REPO"])
        results = []

        label_name = "issue-agent"
        existing_labels = [label.name for label in repo.get_labels()]
        if label_name not in existing_labels:
            repo.create_label(
                name=label_name,
                color="f29513",
                description="Auto-generated by Issue Agent",
            )

        for issue in state.get("issues_to_create", []):
            title = issue.get("title", "").strip() or "Untitled"
            body = issue.get("body", "").strip() or "No description provided."

            full_title = f"[Issue Agent] {title}"
            full_body = f"{body}\n\n---\n_This issue was generated automatically by `issue-agent [Generator-sub-agent]`._"

            created = repo.create_issue(
                title=full_title, body=full_body, labels=[label_name]
            )
            results.append(created.html_url)
            print(f"âœ… Created issue: {full_title}")

        return {**state, "generation_result": results}

    return run


def should_create_issues(state: AgentState) -> str:
    return "create" if state.get("decision") else "end"


def build_multi_agent_issue_graph(llm, tools, compile_graph=True):
    graph = StateGraph(AgentState)

    graph.add_node("reviewer", reviewer_node(llm, tools))
    graph.add_node("generator", generator_node())

    graph.set_entry_point("reviewer")
    graph.add_conditional_edges(
        "reviewer",
        should_create_issues,
        {
            "create": "generator",
            "end": END,
        },
    )
    graph.add_edge("generator", END)

    # display(Image(graph.get_graph().draw_mermaid_png()))
    if compile_graph:
        return graph.compile()
    return graph


def get_graph_dot_string(llm, tools):
    builder = build_multi_agent_issue_graph(llm, tools, compile_graph=False)
    return builder.get_graph().get_dot()
